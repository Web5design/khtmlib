<html>
<head>
</head>
<body>
<h1>Programmers dokumentation</h1>
This library has an API. If somebody want to do a faster map renders, there are two ways. Start a new project, this API would be a good starting point. If a new API would have the same API there could benchmark and compatibility tests could be made. 
<br/>
The other way to increase speed is to work on this API.
<h2>Software architecture</h2>
The OO syntax is like described in 
http://de.wikipedia.org/wiki/JavaScript#Objekte
<br/>
Event handling for Objects is done by the Event function. I found it somewhere in cyberspace.
<h3>Layer</h3>
<code>
this.draw=function(map,lat,lng, moveX, moveY, intZoom,zoom){
...
}
</code>
<br/>
<br/>
This Method draws a layer. 
map is the div element where the map will be rendered.
lat, lng defines the center of the map.
<br/>
<h6>moveX, moveY</h6> It's much faster to move a div than to move every single image.
If the users moves the map with mouse the moveX, moveY will given to this function. It's for speedup and will be discussed later. The moveX and moveY technique is faster but can make the internals difficult to understand.
<br/>
<h6>zoom, intZoom:</h6> If zoom is set to 8.56 and intZoom is set to 10, the images for zoomlevel 10. For example this image:<br/>
<img src="http://a.tile.openstreetmap.org/10/234/420.png"/> <br/>
But it would be rendered smoller because or the zoom level.<br/>
<img src="http://a.tile.openstreetmap.org/10/234/420.png" style="width:94px;height:94px"/> 
<br/>
The map paramenter defines the DIV used for drawing the images.
The result of this method is a map that has basic functionality.
The moveX and moveY parameters make it easy to move around this map.
The zoom should also work and can for this example be set like:
<br/>
<code>
zoom=Math.floor(zoom);
</code>

<!-- jetzt kommt die karte -->

<h3>Layermanager</h3>
This method does the same as "draw" but desides the intZoom with an intelligent mechanism.
<br/>
<br/>
<code>
this.layer=function(map,lat,lng, moveX, moveY, zoom){
...
}
</code>
<br/>
<p>
For every integer zoomlevel we create a layer (object draw) if needed.
This Method handles the layers. It decides which layer should be displayed and in which layer the next images should be loaded.
</p>
<p>
It also handles the frequency layers are drawn. 
If a higher level method sends every millisecond that the map should move a bit moved a bit, this layer will ignor all requests if its busy. This is made with strange setTimeout semaphores. Using object variables as semaphores is not working.
<br/>
To be more clear on that. Every mouse event can give a command to the map. That means the program execution forks a new task. If there are many mouse events there are many tasks doing things that are not needed anymore. To avoid parallel threads there are semaphores nessessary.
<br/>
A big problem here is the cheating firefox. Firefox gives the image rendering to a seperate thread and continues in code. Firefox will get too many rendering requests and will be a bit slow if there are too many requests. WebKit browsers work fine on that and they are really really fast.
</p>
<h5>3d css</h5>
WebKit browsers, including iPhone, have support for 3D CSS. The 3D CSS uses hardware support for transforming things. 3D is faster than 2D but can be used for 2D.
<br/>
All the layers are 3D layers and can be moved around very smooth.
iPhone has full 3D CSS support and it would be possible to make a perspective view. It's just changing one parameter from 0 to an arbitray angle.

<h5>Cleanup</h5>
<p>
This library tries to avoid preload completely. 
If the user moves the map very fast (zoom!) he will request many images.
Sometimes the server can not deliver in the short time. If the user does not need the image anymore, the request will be canceled.
This task brings lots of performance. But the bad thing is, that webkit browsers don't honor my effort because of this bug:
https://bugs.webkit.org/show_bug.cgi?id=6656

</p>

</body>
</html>
